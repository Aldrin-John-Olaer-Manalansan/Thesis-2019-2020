/*Thesis Server.jsPerforms communications between user and the appliancesWritten by: John Brell G. LadieroThesis by: John Brell G. Ladiero, Aldrin John Manalansan, Romiel Jan G. Sambat, Remz Anne P. Tolentino*///Serial key and portsconst _smart_home_serial_key_ = 'amFsZSc';const BroadcastPort = 417;// File System / OSconst path = require('path')const fs = require('fs')const convert = require('base64-js')//Serverconst https = require('https')const url = require('url')const express = require('express')const WebSocket = require('ws');//Eventsconst EventEmitter = require('events');class MyEmitter extends EventEmitter {}const trigger = new MyEmitter();// Update ngrokvar ngrok = fs.readFileSync(path.resolve('bridge/link.txt'));console.log(ngrok);var script_url = "https://script.google.com/macros/s/AKfycbxRNGjh4HadFn__jIp_tSmp5Tf_hQdhCJlWTwzxiRFx4n9jjI4c/exec?id="+_smart_home_serial_key_+"&name="+ngrok+"&action=update";https.get(script_url, (resp) => {  let data = '';  // A chunk of data has been recieved.  resp.on('data', (chunk) => {    data += chunk;  });  // The whole response has been received. Print out the result.  resp.on('end', () => {    console.log(data);    //console.log(JSON.parse(data).explanation);  });}).on("error", (err) => {  console.log("Error: " + err.message);  console.log(data);});//Root CArequire('ssl-root-cas').inject().addFile(path.resolve('ssl/server/my-private-root-ca.crt.pem'));//Front Endconst FrontEnd = https.createServer({}, function (req, res) {    res.writeHead(200, {'Content-Type': 'text/html'});    res.write("hello world\n")    res.end();  }).listen(443);  console.log('Broadcasting');// Home OBJECTfunction log(){  console.log('log');}console.log('Online');var Session = 0;const wss = new WebSocket.Server({ noServer:true });wss.on('connection', function connection(ws) {  var session = `id_${++Session}`;  var token;  ws.send(JSON.stringify({code:'handshake', data:'inactive'}));  // Message from client  ws.on('message', function incoming(message) {    // Check if user follows standard    console.log('received: %s', JSON.stringify(message));    try{    var user_request = JSON.parse(message);    }    catch(e){      ws.close()      console.log('A user has been rejected. Format is not in json');      console.log(JSON.stringify(message));      return;    }    //Handshake    if(token==null){      //check validity      if(!user_request.hasOwnProperty('key') &&!user_request.hasOwnProperty('type')){        ws.close(); console.log('User does not comply');      }      if(user_request.key==_smart_home_serial_key_ && user_request.code=='serial' ){        //Generate stamp        token = Date.now();        ws.send(JSON.stringify({ code:'acknowledge', token:token  }));        console.log('User has been acknowledged. Sending token: '+ token);        CCTV.snap(session);        DataStorage.users.push(session);        return;      }      else{ console.log('User has the wrong key'); ws.close(); }        return;     }    //Check validity    if(DataIsComplete(user_request, ['code','stamp'])){      if (user_request.stamp==token){        user_request.session = session;        RequestHandler(user_request)      }    }    else{      console.log('Data is incomplete');      console.log(JSON.stringify(user_request));    }  });  // Active messaging where the server sends data automatically when file change occurs  ws.pushData = function(data,type='',debug=true){    if (debug) { console.log(`Sending ${type} to ${session}...`);}    ws.send(JSON.stringify(data));    if (debug) { console.log('Sent\n');}  }  ws.udpateUser = function(){    DataStorage.userData(session)  }  // Independent object listener  trigger.on(session, ws.pushData)  ws.on('close', function() {  console.log(`User leaved in session ${session} \n\n`);  try {CCTV[session].close()} catch (e) {}  trigger.removeListener(session, ws.pushData);  DataStorage.users = DataStorage.users.filter(function(value, index, arr){    if(value!=session) return value;});});});//Server SetupLocal = https.createServer(  {    key: fs.readFileSync(path.resolve('certs/server.key.pem')),    cert: fs.readFileSync(path.resolve('certs/server.crt.pem')),  });Local.on('upgrade', function upgrade(request, socket, head) {  const pathname = url.parse(request.url).pathname;  if (pathname === '/ws') {    wss.handleUpgrade(request, socket, head, function done(ws) {      wss.emit('connection', ws, request);    });  }  else {    socket.destroy();  }});Local.listen(BroadcastPort);//GlobalGlobal =require('http').createServer(function (request, response) {   // Send the HTTP header   // HTTP Status: 200 : OK   // Content Type: text/plain   response.writeHead(200, {'Content-Type': 'text/plain'});   // Send the response body as "Hello World"   response.end('Hello World\n');})Global.on('upgrade', function upgrade(request, socket, head) {  const pathname = url.parse(request.url).pathname;  if (pathname === '/ws') {    wss.handleUpgrade(request, socket, head, function done(ws) {      wss.emit('connection', ws, request);    });  }  else {    socket.destroy();  }});Global.listen(6969);// File Handler / Watcher//// Methodsconst RequestHandler = function(user_request){  switch (user_request.code) {    //User Fetch Data    case 'fetch':      if(DataIsComplete(user_request,['session'])){        DataStorage.userData(user_request.session);      }      break;    //Socket Manipulation    case 'register':      if(DataIsComplete(user_request,['serial','device'])){        if(user_request.device=='appliance'){ user_request.serial = Array.from(convert.toByteArray(user_request.serial+'=')); }        DataStorage.queue('register',user_request.serial,user_request.device );      }      break;    case 'rename':      if(DataIsComplete(user_request,['serial','socket','name','device'])){        if(user_request.device=='appliance'){ user_request.serial = Array.from(convert.toByteArray(user_request.serial+'=')); }        DataStorage.queue('rename', user_request.serial, {name:user_request.name, device:user_request.device }, user_request.socket);      }      break;    case 'remove':      if(DataIsComplete(user_request,['serial','item'])){        if(user_request.item=='appliance'){ user_request.serial = Array.from(convert.toByteArray(user_request.serial+'=')); }        DataStorage.queue('remove',user_request.serial,user_request.item);      }      break;    case 'automation':      if(DataIsComplete(user_request,['serial','socket','automation_enabled','automation'])){        user_request.serial = Array.from(convert.toByteArray(user_request.serial+'='));        DataStorage.queue( 'automation', user_request.serial,{ enable:user_request.automation_enabled, time:user_request.automation}, user_request.socket)      }      break;    case 'toggle':      if(DataIsComplete(user_request,['serial','state','socket'])){        user_request.serial = Array.from(convert.toByteArray(user_request.serial+'='));        DataStorage.queue('toggle', user_request.serial, user_request.state,user_request.socket,);      }      break;    //CCTV    case 'frame':      if(DataIsComplete(user_request,['serial','session'])){        CCTV.frame(user_request.serial, )      }      break;    case 'feed':      if(DataIsComplete(user_request,['intent','data','serial','session'])){        CCTV.feed(user_request)      }      break;    default:    console.log('Message not recognized: '+ JSON.stringify(user_request));  }};const DataIsComplete = function(sample, reference){  var isComplete=true  received_data = Object.keys(sample);  reference.map( information =>{    if(!received_data.includes(information)) {console.log('Corrupted data. Missing: '+ information); isComplete=false;}  })  console.log(sample.code + (isComplete?' request is complete...' : ' request is not complete'));  return isComplete;};const DataStorage = {  init: function(){    this.home = this.get('userdata');    fs.watch(path.resolve('bridge/userdata.json'), {persistent: true}, function(event, filename) {      clearTimeout(this.filechange);      this.filechange = setTimeout(function(){        var bridge = JSON.parse(fs.readFileSync(path.resolve('bridge/queue.json')));        var timestamp = JSON.parse(fs.readFileSync(path.resolve('bridge/userdata.json'))).timestamp;        console.log('timestamp: ' + timestamp);        bridge = bridge.filter(request =>{ return request.timestamp > timestamp });        console.log('Queue: '+JSON.stringify(bridge));        fs.writeFileSync(path.resolve('bridge/queue.json'), JSON.stringify(bridge));        console.log(event + " event occurred on " + filename); /* Debug */        DataStorage.users.map((user)=>{          DataStorage.userData(user);        })      },500);    });  },  users:[],  filechange:{},  get: function(name){    file = `bridge/${name}.json`;    data=null;    for (var i = 0; i < 10; i++) {      try { data = JSON.parse(fs.readFileSync(path.resolve(file))); break; } catch (e) {}    }    return data  },  queue: function(request, serial='', data=0, socket=1,){    data = {request:request, serial:serial, socket:socket, data:data, timestamp:Date.now()};    cache = JSON.parse(fs.readFileSync(path.resolve('bridge/queue.json'))),    cache.push(data); console.log(cache);    fs.writeFileSync(path.resolve('bridge/queue.json'), JSON.stringify(cache));  },  userData: function(session){    var logs=[];    var consumption = {};    this.home = this.get('userdata');    home = this.home;    home.appliance.map( sample =>{      try {        logs = logs.concat(Object.keys(sample.consumption));      } catch (e) {        console.log(Object.keys(sample.consumption)+ sample.name);      }    });    logs.sort();    logs = [...new Set(logs)];    //Loop through addresses to all appliance    // Add Their values to form a total    //Append values to home total    //Repeat for home data    logs.map( log=>{      //Check if home has the object      consumption[log]={data:[0], total:0};      home.appliance.map( appliance=>{        var total = 0;        try {          appliance.consumption[log]['total']=total;          appliance.consumption[log].data.map((val,i)=>{            val = Math.round(val * 100) / 100;            if(consumption[log].data[i]==null){              consumption[log].data[i]=val;              total+=val;            }            else{              consumption[log].data[i]+=val;              total+=val;            }            total = Math.round(total * 100) / 100;            consumption[log].data[i]= Math.round(consumption[log].data[i] * 100) / 100          });          consumption[log]['total']+=Math.round(total * 100) / 100;          appliance.consumption[log]['total']=total || 0;          appliance.consumption[log]['total']+=0;        } catch (e) { /* Skip */}      });    });    logs.map( log=>{      var total=0;      consumption[log].data.map( val=>{        total+=val;      });      consumption[log]['total']=Math.round(total * 100) / 100;    })    home.camera.map(cctv=>{ cctv.serial = convert.fromByteArray(cctv.serial).replace('=','') })    home.appliance.map(cctv=>{ cctv.serial = convert.fromByteArray(cctv.serial).replace('=','') })    home['consumption']=consumption;    // Send data to client    trigger.emit(session, {code:'data', data:home}, 'data');  },}const CCTV = {  isOnline:false,  snap: function(session){    console.log('Getting snaps...');    var home = DataStorage.home    home.camera.map(cam=>{        init = false;        try {          var tunnel = new WebSocket(cam.socket);          tunnel.onmessage = e=>{            if(init){ return; } else { init = true; }            console.log('Serial '+cam.serial);            Message = {code:'snap', data:convert.fromByteArray(e.data), serial:cam.serial}            trigger.emit(session, Message, 'snap');            tunnel.close();          }          tunnel.onerror=e=>{ tunnel.close(); console.log('Snap error: ' + e.message);}        }        catch (e) {console.log('Failed to load socket frame: '+e);}      });  },  feed: function(user_request){    switch (user_request.intent) {      case 'start':        this.start(user_request.serial, user_request.session)        break;      case 'stop':        if(!CCTV.isOnline){console.log('CCTV is offline'); return}        try { CCTV[user_request.session].close() } catch (e) {console.log('Failed to close cctv');}          break;      case 'send':        try { CCTV[user_request.session].send(user_request.data) }        catch (e) {          trigger.emit(user_request.session, {code:'notification', data:'The CCTV is offline.'}, false,false);          console.log('Failed command cctv');          CCTV.isOnline=false;        }        break;      default:    }  },  start: function(serial,session){    DataStorage.home.camera.map(cam=>{      if(cam.serial==serial){        console.log('Trying to open socket');        CCTV[session] = new WebSocket(cam.socket);        CCTV.onopen=()=>{ CCTV.isOnline=true; console.log('CCTV is broadcasting...');}        CCTV[session].onmessage = e=>{          Message = {code:'live', data:convert.fromByteArray(e.data)}          trigger.emit(session, Message, false,false);}        CCTV[session].onerror=e=>{ CCTV[session].close(); console.log('Error: '+ e.message);        trigger.emit(session, {code:'notification', data:'The CCTV has been disconnected.'}, false,false);        }        CCTV[session].onclose=()=>{ CCTV.isOnline=false; console.log('Socket Closed. (Live)');}      }      });  },}DataStorage.init()console.log(JSON.stringify(DataStorage.home));